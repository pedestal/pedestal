= What is an Interceptor?
Michael Nygard
2017-06-26
:jbake-type: page
:toc: macro
:icons: font
:section: guides

toc::[]

_by {author}_, _{revdate}_

== Welcome

It doesn't take very long to bump into the word "Interceptor" when
you're working with Pedestal. They're the most important construct in
the library. Pretty much everything is an interceptor, including some
of the things that would normally be built in to a framework.

== What You Will Learn

After reading this guide, you will be able to:

- Explain the role of interceptors in Pedestal
- Compare interceptors to middleware
- Create interceptors that affect execution of remaining interceptors
- Handle errors

== Guide Assumptions

This guide is for intermediate users who have worked through some
sample applications or the first few link:hello-world[Hello World]
guides. In particular, you should know how to run a build, start a
REPL, and start and stop your server.

You do not need to know any other Clojure web frameworks, but if you
do, you may find some of the comparisons useful. If not, that's OK,
just skip those sections.

== Getting Help if You're Stuck

If you get stuck at any point in this guide, please submit an
https://github.com/pedestal/docs/issues[issue] about this guide or hop
over to the
https://groups.google.com/forum/#!forum/pedestal-users[mailing list]
and raise your hand there. You can often find help in the `#pedestal`
channel of the https://clojurians.slack.com[Clojurians Slack team.]

== Where We Are Going

We're going to start with a fresh, empty project in this guide, with
just one interceptor. It will help illustrate the concepts we dive
into next.  After that, it's time to talk about the execution model
and see how we can make interceptors that change the request-handling
process dynamically.

Finally, we have to talk about error handling.

== Before We Begin

Make sure you have https://leiningen.org/[Leiningen] installed. We'll
be using it to run our project and to build a project from a template
later.

Feel free to consult the full source in
https://github.com/pedestal/docs/tree/master/content/guides[the
repository], but be warned that the file contains all the versions
that we built up through the previous guide. You'll need to navigate
some magic comments to pare it down to just the final version.

== A Place to Put Things

We need a project to contain our interceptors while we build them. For
now, let's make a project by hand so we understand each part. (In a
real project, you would probably use the Leiningen template to create
your new project.)

Make a directory for your project and drop this into `project.clj`:

[[app-listing]]
[source,clojure]
----
include::what-is-an-interceptor-src/project.clj[]
----

This is as basic as it gets, but it's enough to run `lein repl` and
get to work. Go ahead and start a REPL.

Do take note of the two dependencies about logging. If you leave these
out, then you won't get any kind of logging, because slf4j will use
its "no-op" logger.

Make a file under `src/service.clj` with the following contents:

[[app-listing]]
[source,clojure]
----
include::what-is-an-interceptor-src/src/intc/service.clj[tags=start;run_service]
----
<1> We will fill in a route shortly
<2> Run on port 8822
<3> Give back our REPL thread after starting
<4> Start a Jetty server to handle HTTP requests
<5> Use the routes from <1>
<6> Expand this "starter" service map into a ready-to-run map
<7> Run it

Load that into your REPL and run `start`. Be sure to bind the return
value from `start` to something so you can stop it later.

== Interceptor From Map

An interceptor is a value. That means it acts like any other value in
Clojure: you can pass it to a function or get it back as a return
value. You could put it in an atom, a ref, an agent, or pass it on a
channel.

Importantly, an interceptor is a _shared_ value: any number of requests may be processed
at the same time by a server, and an interceptor in that service's routes may be simultaneously
invoked across many threads at the same time.  Likewise, a single interceptor may be added
to multiple routes.

The simplest way to create an interceptor is by just making a map. Any
map that has at least one key of :enter, :leave, or :error can
be used as an interceptor.

The :enter and :leave functions take a single argument, the context;
the :error function takes two arguments: the context, and an exception.

We'll create a really basic interceptor that responds to every HTTP
request with "Hello, world!".

[[app-listing]]
[source,clojure]
----
include::what-is-an-interceptor-src/src/intc/service.clj[tags=hello]
----

There are a couple of things to point out here. First, this is
defining a var in the namespace and binding it to the value in the
map. That means the map is evaluated at compile time.

Second, the map has a :name key. That's not one of the required
keys, but if it exists, Pedestal will print it in some debug messages
and logs. Having the logging tied back to the specific interceptor can help you narrow down problems later.

The :enter key is where things get a little more interesting. (A
little, but not much. It's just "hello world" after all.) Note that it
has a function that assocs a value onto the context under the
:response key. That value happens to be shaped in a way that the
link:../reference/servlet-interceptor[Servlet Interceptor] looks for.

This is where we have to start being precise about the difference
between an interceptor and how it gets invoked. "Interceptor" is a very
general concept. It can be used in a lot of different ways, not just
for HTTP handling in a web framework. In fact, the base of Pedestal's HTTP handling comes
from the api:pedestal.service[ns=io.pedestal.http]
module. Interceptor invocation and handling comes from
api:pedestal.interceptor[ns=io.pedestal.interceptor]
which doesn't depend on pedestal.service.

For example, there is a project that lets you invoke a chain of
interceptors when a message arrives on a link:https://github.com/cognitect-labs/pedestal.kafka[Kafka topic]. You could invoke
interceptors to do batch processing. Generally speaking, interceptors are an implementation of the
"pipes and filters" architecture pattern.

Pedestal arranges to call interceptors on one of three functions at different times:

=== 1. Enter

The :enter function is called on the "way in" to a bunch of
interceptors. If you look at a route with a collection of
interceptors, they'll have their :enter functions invoked from
left-to-right. Each one receives the new value of the context returned
by the previous one.

=== 2. Leave

The :leave function is called on the "way out" of a bunch of
interceptors. That same collection of interceptors on a route will be
called from right-to-left. Like the enter functions, each leave
function receives the context and returns a (possibly modified)
context.

=== 3. Error

The :error function is a bit special. If an interceptor throws an
exception, then Pedestal starts looking for an interceptor with an
:error function to handle it. This goes from right-to-left like the :leave
functions. The main difference is that an error-handling interceptor
may indicate that the error is totally resolved and Pedestal will
resume looking for :leave functions. See <<Error
Handling>> below for all the gory details.

== The Queue and the Stack

Pedestal starts running interceptors when the
api:io.pedestal.interceptor.chain/execute[ns=io.pedestal.interceptor.chain] function is invoked.
Normally, this the job of the link:../reference/chain-providers[chain provider]; in HTTP terms,
a servlet is plugged into Jetty and the servlet kicks off the interceptor chain by invoking `execute`.

Your code can call `execute` with an empty context and a collection of interceptors, or you can call it with a context that already has interceptors enqueued. (In the former case, Pedestal just enqueues the interceptors on the context then calls the second form.)

Suppose we start with three interceptors in the queue, like this.

image::../images/guides/what-is-an-interceptor/interceptor-queue-and-stack-in-context-1.png[]

Pedestal needs to call the :enter function on "Intc 1". So it pops that interceptor from the queue and moves it to the stack. Then it calls the interceptor, passing the context map itself. This is the context as it appears to "Intc 1".

image::../images/guides/what-is-an-interceptor/interceptor-queue-and-stack-in-context-2.png[]

When that's done, the next thing is to call "Intc 2". Same thing happens, Pedestal pops that interceptor from the queue and pushes it on the stack.

image::../images/guides/what-is-an-interceptor/interceptor-queue-and-stack-in-context-3.png[]

Repeat the process for "Intc 3" and we're left with this context map.

image::../images/guides/what-is-an-interceptor/interceptor-queue-and-stack-in-context-4.png[]

== Manipulating the Queue

When Pedestal calls an interceptor, the queue and stack aren't just
there for informational use. Interceptors are totally allowed to
change things up. Before we move on, though, we need to revisit the
topic of _what_ an interceptor is.

Remember when I said that any map that has at least one key of
:enter, :leave, or :error can be used as an interceptor? Well it
turns out that is not completely true. While an interceptor used in
routing can be represented as a map, an interceptor enqueued during
queue manipulation _must_ be an Interceptor record instance, otherwise
an exception is thrown. While this subtlety is called out the
link:../reference/interceptors#_manipulating_the_interceptor_queue[Interceptors]
reference documentation, it's worth reiterating here. When maps are
used as interceptors in routes, they are expanded to Interceptor
records during route expansion. For performance reasons, no such
transformation occurs when interceptors are enqueued. *Enqueued interceptors
are expected to be Interceptor record instances*.

Now that we've cleared that up, let's work through an example where we
dynamically decide which interceptor to add, depending on a query
parameter.

First we'll change `service.clj` to add two new claims beyond "Hello
World."

[[app-listing]]
[source,clojure]
----
include::what-is-an-interceptor-src/src/intc/service.clj[tags=new_players]
----
Notice how we use the `io.pedestal.interceptor/interceptor` function
to create the Interceptor records. This is because we'll be
`enqueue`-ing them during request processing.

[TIP]
.*Interceptors vs. Maps*
--
Interceptors added the service's routes can be simple maps (and various other things, such as Vars and symbols); they will be
expanded into interceptor records automatically.
Interceptors that are dynamically enqueued by your application code must already be interceptor records, via
the api:interceptor[ns=io.pedestal.interceptor] function.
--

Now, these interceptors aren't very interesting, but there are two of
them. Here's how we are going to choose which one to run.

[[app-listing]]
[source,clojure]
----
include::what-is-an-interceptor-src/src/intc/service.clj[tags=chooser]
----
<1> Look at the `n` query parameter from the URL.
<2> Enqueue one or the other of our interceptors.
<3> Generate a response if neither of the interceptors apply.

Be careful with the call to `enqueue`. It's meant to add many interceptors at once, so it takes a collection as the second argument.

Restart your server (since we're not running in dev mode, we don't get automatic reloading) and try it out with cURL. You should be able to get any of the three responses. If you get an internal server error, it means there's something wrong in the code.

=== Interceptors vs. Middleware

The very first motivation for Pedestal was the ability to make on-the-fly decisions about how to handle requests. Middleware models wrap up the whole processing chain in function closures -- a stack of functions wrapping other functions.

Not only are such function stacks opaque, but the decisions are all made at compile time. In contrast, Pedestal treats the processing chain like a virtual call stack, or a malleable program to execute; its malleable because any interceptor can decide to enqueue new interceptors for execution.

=== Some Practical Applications

Pedestal routers are just interceptors. A router inspects the incoming request and decides what interceptors to enqueue. That's it! There's no magic at all in the router. You can build your own replacement router. For that matter, you can build a secondary router that uses something other than the request path to dispatch on.

Suppose you need to add entity-level access control to an API. You can create an interceptor that looks at the entity to decide if authorization is needed. If so, enqueue an interceptor that does the auth check or redirects.

Most controller logic takes this form:

1. Get information from the request.
1. If the request can't be done, generate an error response.
1. Fetch some data.
1. Decide what operation to perform on the data.
1. Decide if the operation can be done on the data.
1. If so, attempt an operation on the data.
1. If not, generate an error response.
1. Attempt to store some data.
1. If it fails, generate an error response.
1. Otherwise, generate a response.

Every place the words "decide" or "if" appear here, you could enqueue different interceptors. This breaks the controller logic down into a handful of very small pieces that each consume and produce context maps. They are easily tested in isolation from a database or external service.

You can create a state machine, where one interceptor examines the current state, then enqueues an interceptor appropriate to handle that state.

Once you start looking at the interceptor queue like a program and the stack like a program stack, you'll find many ways to use dynamic dispatching.

== Error Handling

Our data "science" interceptor is pretty small, but it still does just a bit too much work. We'd like to separate error handling from the main flow of logic. What happens if we just let `chooser` throw an exception?

[[app-listing]]
[source,clojure]
----
include::what-is-an-interceptor-src/src/intc/service.clj[tags=chooser2]
----

If the `n` query parameter isn't an integer, then the request will fail
with the dreaded "Internal server error." and a 500 response.

We've failed our users by not providing them with the feedback they need, in our response,
to understand why the request failed.  We should fail with a 400 (Bad Request) response and
an understandable error message as the response body.

You might be tempted to simply wrap the call to `Integer/parseInt` in a `try/catch` block ... BUT,
that will only catch a single case; what happens when your application grows and there are multiple places
that numbers need to be parsed?

What we want is to catch _any_ `NumberFormatException` and provide a reasonable response.
If we were using normal functions calling functions, we could shift the `try/catch` out, higher; since
we are using an interceptor chain, we instead can use an Interceptor to handle these errors.

When an interceptor throws an exception, Pedestal will begin to search up the stack of interceptors
for a interceptor with an :error function.

Pedestal calls the :error function with the context map and an exception object that wraps the original exception. (See the link:../reference/error-handling[error handling reference] for all the gory details.)

We can make an interceptor that handles `NumberFormatException` as so:

[[app-listing]]
[source,clojure]
----
include::what-is-an-interceptor-src/src/intc/service.clj[tags=error-i]
----
<1> Check what type of exception was originally thrown.
<2> Create a response for our specific error of interest.
<3> Tell Pedestal to keep looking for an error handler for anything else. (I.e., "rethrow" the exception.)

This works, but it's still a bit noisy.  This is a common enough problem that Pedestal has a helper for it,
api:error-dispatch[ns=io.pedestal.interceptor.error].

Let's rewrite `number-format-handler` using `error-dispatch` to create the interceptor for us.

[[app-listing]]
[source,clojure]
----
include::what-is-an-interceptor-src/src/intc/service.clj[tags=error-dispatch]
----
<1> Use pattern matching to select which exceptions we handle.
<2> Generate a response. Any exceptions that don't match a pattern automatically get rethrown.

This recreates the same logic as before: handle `NumberFormatException`, or resume searching for
an Interceptor that can handle the original exception; it's just very concise.

There's a link:../reference/error-handling#_error_dispatch_interceptor[reference to error-dispatch]
that explains in more detail what you can match on and how.


== IntoInterceptor

When you specify an interceptor to Pedestal, you don't have to provide a map; in places where an
interceptor is expected, the value you provide is converted to an interceptor using the
`IntoInterceptor` protocol.

What can you provide instead of a map?

- An `Interceptor` record stays as is
- A bare function is treated as a handler
- A namespace qualified symbol is passed to `resolve`; the result is then turned into an Interceptor
- A Var is passed to `deref`; the result is then turned into an Interceptor
- A list is passed to `eval` ... it's treated like a function call; the result is then turned into an Interceptor

All of these are handled to make route specifications more readable and concise, or to support
link:live-repl[live reloading of code into the REPL during development].

So, what's a handler?  It's a narrow-focused version of an interceptor that is triggered on :enter;
the handler function is passed just the :request map from context, and the response is expected to
be a response map, which is dutifully attached as the :response key of the context.

The api:interceptor[ns=io.pedestal.interceptor] function is used to
convert values into Interceptors; it also checks that at least one of :enter, :leave, and :error is
provided.

== The Path So Far

In this guide, we've gotten into some of the deep inner workings of Pedestal. You've learned:

* How Pedestal invokes interceptors.
* How to manipulate the interceptor queue and stack.
* How to split your application logic into smaller pieces using interceptors.
* How to handle errors


== Where To Next?

You may want to head over to some of the references for full details:

* link:../reference/interceptors[Interceptors]
* link:../reference/default-interceptors[Default Interceptors]
* link:../reference/context-map[Context Map]
* link:../reference/error-handling[Error handling]
