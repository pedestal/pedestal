# Delta Detecting Model

In Pedestal, a model is represented as a tree or nested map. For
example, a simple model could be:

```clj
{:counter {:a 1 :b 2}}
```

This model represents two counters `a` and `b`. What values does this
model contain? At the path `[:counter]` is stored the value `{:b 1 :c 2}`.
At the path `[:counter :a]` is stored the value `1` and at the
path `[:counter :b]` is stored the value `2`.

What constitutes a value is application specific. One application may
treat `{:a 1 :b 2}` as a value that is always viewed and updated
together. Another may only deal with the values `1` and `2`.


## Delta Detection

This document is about delta detection. When the model changes, we
would like to know what is different about it so that we know how to
respond to the change. From the perspective of the delta detector, the
map above contains only two values: the value at `[:counter :a]` which is
currently `1` and the value at `[:counter :b]` which is currently `2`.

The delta detector always reports the most specific change. If the
model above is changed to

```clj
{:counter {:a 1 :b 3}}
```

the path `[:counter]` has changed but this is only true because
`[:counter :b]` changed from `2` to `3`. Therefore the change to
`[:counter :b]` is reported.


## Model Inform

Changes to the model are reported as an inform message.

```clj
[event-entry ...]
```

Each `event-entry` describes a specific change.

```clj
[source event state ...]
```

The specific change above would generate the following inform message

```clj
[[[:counter :b] :update {:counter {:a 1 :b 2}} {:counter {:a 1 :b 3}}]]
```

Event entries for changes to the model contain

1. the path which changed
2. the change event (:added | :updated | :removed)
3. the whole model before the change
4. the whole model after the change

The rest of this document is about how we efficiently generate these messages.


## Algorithms

We need to come up with an algorithm that efficiently generates inform
messages. Below we consider four algorithms:


### :naive

The `naive` algorithm takes the old model and the new model and
traverses the model twice to find additions, updates and removals. This
algorithm is simple to understand and it is easy to see that it
generates the expected results. We use this algorithm to check that
other algorithms are correct.

We would expect this to be slow when the model is large.


### :simple

Transform messages contain the path where the transform is applied. If
we keep track of these paths we can use them to limit the parts of the
tree that we search for changes.

The `simple` algorithm is the same as the `naive` algorithm except that it
keeps track of transform paths and then only traverses the parts of
the tree that could have possibly changed.

We would expect this to be fast when the transform path points to the
exact value that was changed.


### :complex

This is the algorithm that Pedestal (on master) currently uses. This
algorithm wraps the model in a `tracking map` which monitors all
changes made to the model.

Suppose we have a model which has a path `[:a :b :c :d :e]`. If we
apply the transform

```clj
[[:a :b :c :d :e] inc]
```

Then the `simple` algorithm knows exactly what changed. What if we apply
this transform?

```clj
[[:a :b] custom-transform-fn]
```

The `simple` algorithm would have to search everything under `[:a :b]`
for changes because `custom-transform-fn` can do anything.

The complex algorithm uses the `tracking map` to record what is being
changed by `custom-transform-fn`.

It can't see all changes so there is still a bit of searching, but much
less that any other algorithm. The problem with this algorithm is that
it is very complicated and requires different implementations in both
Clojure and ClojureScript. Also, wrapping has some cost that we always
pay. Is this cost worth it?


### :hybrid

The `hybrid` algorithm is a combination of `naive` and `complex`. In this
algorithm we use the `tracking map` to find paths that have
changed. As mentioned above, sometimes we do have to search areas of
the model where the changes were not clear. This algorithm uses the
paths generated by the `tracking map` to feed into the `naive` algorithm
for search. It combines detailed knowledge of what has changed with an
understandable way of searching for changes.


## Performance

The question has always been, how much cost is there to always using
the complex algorithm? In the performance tests below, we compare each
of the four algorithms on models of different shapes and sizes as well
as with different types of operations.

Except for the first test, each test is a summary of multiple
runs. The fields mean:

`:scale`  : how much slower is this algorithm?
`:event`  : is the path and event correct?
`:inform` : is the whole inform messages correct?
`:changes`: number of changes reported
`:m`      : name of the algorithm used
`:mean`   : the mean
`:sd`     : the standard deviation

All times are in milliseconds.

```
3 items 1-3-1 dissoc node / 1 runs

| :scale | :event | :inform | :changes |       :m | :mean |   :sd |
|--------+--------+---------+----------+----------+-------+-------|
|  1.000 |   true |    true |        1 |   :naive | 0.068 | 0.000 |
|  1.735 |   true |    true |        1 |  :simple | 0.118 | 0.000 |
|  3.912 |  false |   false |        1 | :complex | 0.266 | 0.000 |
|  4.544 |   true |    true |        1 |  :hybrid | 0.309 | 0.000 |

1000 items 10-10-10 inc / 100 runs

| :scale | :event | :inform | :changes |       :m | :mean |   :sd |
|--------+--------+---------+----------+----------+-------+-------|
|  1.000 |   true |    true |        1 |  :simple | 0.031 | 0.000 |
|  4.460 |   true |    true |        1 |   :naive | 0.140 | 0.003 |
|  7.441 |   true |    true |        1 |  :hybrid | 0.233 | 0.001 |
| 14.395 |   true |    true |        1 | :complex | 0.450 | 0.315 |

10000 items 10-100-10 update-in node / 100 runs

| :scale | :event | :inform | :changes |       :m | :mean |   :sd |
|--------+--------+---------+----------+----------+-------+-------|
|  1.000 |   true |    true |        2 |  :hybrid | 0.316 | 0.021 |
|  1.123 |   true |    true |        2 |  :simple | 0.355 | 0.051 |
|  1.167 |   true |    true |        2 | :complex | 0.369 | 0.032 |
|  1.379 |   true |    true |        2 |   :naive | 0.436 | 0.061 |

10000 items 10-100-10 dissoc node/update-in node / 100 runs

| :scale | :event | :inform | :changes |       :m | :mean |   :sd |
|--------+--------+---------+----------+----------+-------+-------|
|  1.000 |   true |    true |       11 |  :hybrid | 0.265 | 0.021 |
|  1.009 |  false |   false |        2 | :complex | 0.267 | 0.020 |
|  1.246 |   true |    true |       11 |  :simple | 0.330 | 0.022 |
|  1.284 |   true |    true |       11 |   :naive | 0.340 | 0.018 |

1000000 items 10-10-10-10-10-10 inc / 100 runs

| :scale | :event | :inform | :changes |       :m | :mean |   :sd |
|--------+--------+---------+----------+----------+-------+-------|
|  1.000 |   true |    true |        1 |  :simple | 0.021 | 0.000 |
| 10.364 |   true |    true |        1 |   :naive | 0.216 | 0.020 |
| 18.805 |   true |    true |        1 |  :hybrid | 0.392 | 0.052 |
| 20.253 |   true |    true |        1 | :complex | 0.422 | 0.030 |

1000000 items 100-1000-10 inc / 100 runs

|  :scale | :event | :inform | :changes |       :m | :mean |   :sd |
|---------+--------+---------+----------+----------+-------+-------|
|   1.000 |   true |    true |        3 |  :simple | 0.036 | 0.000 |
|  29.034 |   true |    true |        3 |  :hybrid | 1.056 | 0.081 |
|  32.247 |   true |    true |        3 | :complex | 1.173 | 0.115 |
| 254.805 |   true |    true |        3 |   :naive | 9.270 | 0.818 |

1000000 items 10-10000-10 inc / 100 runs

|   :scale | :event | :inform | :changes |       :m |  :mean |   :sd |
|----------+--------+---------+----------+----------+--------+-------|
|    1.000 |   true |    true |        3 |  :simple |  0.036 | 0.000 |
|  154.414 |   true |    true |        3 |  :hybrid |  5.584 | 0.428 |
|  157.861 |   true |    true |        3 | :complex |  5.708 | 0.457 |
| 2440.907 |   true |    true |        3 |   :naive | 88.263 | 2.147 |

1000000 items 1000-1000 inc / 100 runs

|  :scale | :event | :inform | :changes |       :m |  :mean |   :sd |
|---------+--------+---------+----------+----------+--------+-------|
|   1.000 |   true |    true |        3 |  :simple |  0.034 | 0.000 |
|  19.777 |   true |    true |        3 |  :hybrid |  0.665 | 0.059 |
|  22.725 |   true |    true |        3 | :complex |  0.764 | 0.058 |
| 318.425 |   true |    true |        3 |   :naive | 10.702 | 0.930 |

1000000 items 10-10000-10 update-in node / 100 runs

| :scale | :event | :inform | :changes |       :m |  :mean |   :sd |
|--------+--------+---------+----------+----------+--------+-------|
|  1.000 |   true |    true |        2 |  :hybrid |  2.020 | 0.231 |
|  1.002 |   true |    true |        2 | :complex |  2.024 | 0.224 |
| 14.626 |   true |    true |        2 |  :simple | 29.542 | 0.486 |
| 14.627 |   true |    true |        2 |   :naive | 29.544 | 0.463 |

1000000 items 10-10000-10 dissoc node/update-in node / 100 runs

|  :scale | :event | :inform | :changes |       :m |  :mean |   :sd |
|---------+--------+---------+----------+----------+--------+-------|
|   1.000 |  false |   false |        2 | :complex |  0.247 | 0.024 |
|   1.018 |   true |    true |       11 |  :hybrid |  0.251 | 0.027 |
| 106.505 |   true |    true |       11 |  :simple | 26.263 | 0.533 |
| 106.586 |   true |    true |       11 |   :naive | 26.283 | 0.933 |

1000000 items 10-10000-10 merge / 100 runs

|  :scale | :event | :inform | :changes |       :m |  :mean |   :sd |
|---------+--------+---------+----------+----------+--------+-------|
|   1.000 |   true |    true |        9 |  :simple |  0.062 | 0.000 |
|  18.464 |   true |    true |        9 |  :hybrid |  1.153 | 0.084 |
|  20.408 |   true |    true |        9 | :complex |  1.274 | 0.118 |
| 450.115 |   true |    true |        9 |   :naive | 28.110 | 0.502 |

1000000 items 10-10000-10 merge / 100 runs

| :scale | :event | :inform | :changes |       :m |  :mean |   :sd |
|--------+--------+---------+----------+----------+--------+-------|
|  1.000 |   true |    true |       99 |  :hybrid |  0.683 | 0.055 |
| 14.118 |   true |    true |       99 | :complex |  9.638 | 0.700 |
| 39.261 |   true |    true |       99 |   :naive | 26.801 | 0.510 |
| 39.419 |   true |    true |       99 |  :simple | 26.910 | 0.734 |

1000000 items 10-10000-10 replace / 100 runs

|  :scale | :event | :inform | :changes |       :m |  :mean |   :sd |
|---------+--------+---------+----------+----------+--------+-------|
|   1.000 |   true |    true |       10 |  :simple |  0.059 | 0.000 |
|  18.263 |   true |    true |       10 |  :hybrid |  1.071 | 0.094 |
|  21.900 |   true |    true |       10 | :complex |  1.284 | 0.083 |
| 477.963 |   true |    true |       10 |   :naive | 28.018 | 0.524 |

1000000 items 10-10000-10 replace / 10 runs

| :scale | :event | :inform | :changes |       :m |    :mean |     :sd |
|--------+--------+---------+----------+----------+----------+---------|
|  1.000 |   true |    true |   100899 |  :simple |  279.778 | 129.069 |
|  1.012 |   true |    true |   100899 |   :naive |  283.117 | 186.452 |
|  1.019 |   true |    true |   100899 |  :hybrid |  284.955 | 134.449 |
|  8.468 |  false |   false |    10989 | :complex | 2369.128 | 125.374 |
```

## Executive Summary

The results are interesting. Out of 14 tests the score was

```
:simple  8
:hybrid  4
:naive   1
:complex 1
```

The one time `:complex` won, it got the wrong answer and :hybrid was
just as good so we will give that one to :hybrid. `:naive` is only good
for microscopic models. So the two interesting algorithms are :simple
and :hybrid. With adjusted scores we have:

```
:simple  9
:hybrid  5

:simple's fastest time: 0.021
:hybrid's fastest time: 0.233
```

There were five tests where the results were the same order of
magnitude. A big replacement on a model with 1,000,000 items is slow
for both. With 10,000 items or less the performance is about the
same when `:simple` cannot see the exact changed paths. When
`:simple` can see the exact change then it is 4 to 7 times faster.

Of the remaining 9 tests the score is:

```
:simple 6
:hybrid 3
```

In these tests, the time ranges are

```
:simple 0.021 - 29.542
:hybrid 0.251 -  5.584
```

The `:simple` algorithm loses 3 times. When it loses it loses big, each
time taking more than 26ms.

When the full path to the change is known from the transform the `:simple`
algorithm is at least an order of magnitude faster than `:hybrid`. When
it is not known, the opposite is true. So the best algorithm to use
depends on how the user makes changes to the model.


## Final Question

The current algorithm being used on branch app-v3 is `:simple`.

So which algorithm should we use?

There are at least three options:

1. develop a better algorithm
2. allow the user to choose an algorithm
3. use both and create an adaptive algorithm that monitors execution
times and then dynamically maps transform functions to the best performing
algorithm


<!-- Copyright 2013 Relevance, Inc. -->
